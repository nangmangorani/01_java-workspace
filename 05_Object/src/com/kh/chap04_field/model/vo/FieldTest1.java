package com.kh.chap04_field.model.vo;

/*
 * >> 변수 구분
 * 
 * - 전역 변수 : 클래스 영역에 바로 선언한 변수 -> 클래스 내에서면 어디서든 전역으로 다 사용이 가능함. (외우는 팁! 전체지역!)
 * - 지역 변수 : 클래스 영역내에 어떤 특정한 구역 ({}) 에 선언한 변수 -> 선언된 해당 그 지역에서만 사용 가능
 * 			  * 특정한 구역 : 메소드 {}, 제어문(if, for) {} 등등...
 * 
 * 
 * 1. 전역변수 (접근제한자 무조건 붙음)
 * - 필드 == 멤버변수 == 인스턴스 변수
 * 생성시점 : new 연산자를 통해 객체 생성시 
 * 소멸시점 : 객체 소멸시 같이 소멸
 * 2. 지역변수
 * 생성시점 : 지역변수가 속해있는 특정한 구역({}) 실행(호출)시 메모리 영역에 할당
 * 소멸시점 : 특정한 구역({}) 종료시 소멸
 * 
 * - 클래스 변수 == static 변수 => 예약어 쓸 수 있는데 static이라는걸 쓰면 클래스 변수가 됨. 프로그래밍에선 많이 x
 * 생성시점 : 프로그램 실행(해당 객체가 생성이 안돼도)과 동시에 무조건 메모리 영역(static)에 할당함.
 * 소멸시점 : 프로그램 종료될때 소멸
 * 
 */

public class FieldTest1 { // 클래스 영역 시작
	
//	private int a; // 얘가 전역변수임~
//	
//	public void method1() { 
//		int b = 10; // b는 method1에 국한됨. 메소드입장에서 b는 전역변수, 클래스입장에서 b는 지역변수
//		System.out.println(b);
//		
//		if(true) {
//			int c = 20;
//		}
//		// System.out.println(c); 얘도 안되겠지~
//		
//	}
//	
//	public void method2() {
//		System.out.println(a); // b는안되고 a는됨!ㅋ
//	}
	
	// 멤버변수 (인스턴스 변수) => 전역변수
	private int global; // 클래스 선언시 클래스는 stack, int global은 필드부기 때문에 heap영역에 생성되고 기본으로 0으로 초기화가 됨. 
	
	public void test(int num) { // test 메소드 시작
		// 매개변수 (일종의 지역변수 즉, 메소드 영역 내에서만 쓸 수 있음)
		
		// 지역변수 (메소드 영역내에 선언) => 지역변수에는 접근제한자 같은거 붙이는거 아님
		// int local;
		int local = 10;
		
		// 멤버변수 출력 => 멤버변수는 해당 이 객체 생성시 JVM이 기본적으로라도 초기화
		System.out.println(global); // 초기화 안돼있음. 근데 오류가 안남. heap영역에 생성될 때 초기화가 되니께~
		
		// 매개변수 출력 => 매개변수는 해당 이 메소드를 호출할 때 반드시 값이 전달될거기 때문에 초기화가 안되어있어도됨.
		System.out.println(num); // 초기화 안되어있지만 오류 안난다~. 무조건 하나 넘어옴.
		// 메인메소드에서 만들면 int num은 스택영역에 들어감.
		
		// 지역변수 출력
		System.out.println(local); // 초기화 안되어있으면 오류가 남
		
	} // test 메소드 끝
	
	
	
} // 클래스 영역 끝
